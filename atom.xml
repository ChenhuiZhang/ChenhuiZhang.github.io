<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>天如洗 笙歌起</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-03-31T02:49:06.471Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Hermes Zhang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>container_of探究</title>
    <link href="http://example.com/2022/04/10/container_of/"/>
    <id>http://example.com/2022/04/10/container_of/</id>
    <published>2022-04-10T04:42:27.000Z</published>
    <updated>2024-03-31T02:49:06.471Z</updated>
    
    <content type="html"><![CDATA[<p>From linux 4.14</p><span id="more"></span><pre><code class="hljs plaintext">/** * container_of - cast a member of a structure out to the containing structure * @ptr:        the pointer to the member. * @type:       the type of the container struct this is embedded in. * @member:     the name of the member within the struct. * */#define container_of(ptr, type, member) (&#123;                              \        void *__mptr = (void *)(ptr);                                   \        BUILD_BUG_ON_MSG(!__same_type(*(ptr), ((type *)0)-&gt;member) &amp;&amp;   \                         !__same_type(*(ptr), void),                    \                         &quot;pointer type mismatch in container_of()&quot;);    \        ((type *)(__mptr - offsetof(type, member))); &#125;)</code></pre><p>The <strong>offsetof</strong> is defined as:</p><pre><code class="hljs plaintext">#undef offsetof#ifdef __compiler_offsetof#define offsetof(TYPE, MEMBER)  __compiler_offsetof(TYPE, MEMBER)#else#define offsetof(TYPE, MEMBER)  ((size_t)&amp;((TYPE *)0)-&gt;MEMBER)#endif</code></pre><p><strong>container_of</strong>宏可以把一个结构体成员变量的指针转成该结构体的指针，为了了解它是怎么实现的，首先需要知道结构体在内存中的布局：</p><p><img src="/layout.png" alt="layout"></p><p>首先无论是在栈或者堆上，结构体占用一段连续的内存，内部的成员依次排布（考虑 padding），例如：</p><pre><code class="hljs plaintext">stuct ST&#123;int a;char b;int c;&#125;;</code></pre><p>在 32 位机器上，按 4 字节对齐，结构体 ST 一共占用 12 字节，其中 a 占用 4 个字节，b 占用 1 个字节，后面有三个字节作为对齐，c 也同样占用 4 个字节。</p><p>其次，结构体的起始地址和第一个成员变量的起始地址一致，所以在下面的代码里&amp;s &#x3D;&#x3D; &amp;s.a:</p><pre><code class="hljs plaintext">struct ST s = &#123; 0 &#125;;printf(&quot;s is at %p&quot;, &amp;s);printf(&quot;a is at %p&quot;, &amp;s.a);</code></pre><p>所以基于上面的结论，通过结构体成员的地址，推算出结构体的起始地址就不难了，只需要知道该成员在结构体中的偏移量就可以了，而偏移量其实就如前面说明的，在编译阶段，或者说编译器就可以知道。</p><p>计算偏移量是通过<strong>offsetof</strong>宏来实现的，来看具体的代码：</p><pre><code class="hljs plaintext">#undef offsetof#ifdef __compiler_offsetof#define offsetof(TYPE, MEMBER)  __compiler_offsetof(TYPE, MEMBER)#else#define offsetof(TYPE, MEMBER)  ((size_t)&amp;((TYPE *)0)-&gt;MEMBER)#endif</code></pre><p>首先检查如果有编译器内置的方法__compiler_offsetof就直接调用，否则就模拟一个从0地址开始的结构体，得到成员变量的地址，因为偏移量就是成员变量的地址减去起始地址，而这个方法的精妙就在于把起始地址设置成了0，所以成员变量的地址就是该成员在结构体内部的偏移量。打个比方，用尺子量东西的长度，通常把起始点对准尺子的零刻度，这样另一端对准的尺子刻度就是该物体的长度。</p><p>最后，另外一个条件是，结构体的内存布局是从低地址到高地址的，换句话说，偏移量总为正。</p><p>OK，然后看<strong>container_of</strong>的实现</p><pre><code class="hljs plaintext">void *__mptr = (void *)(ptr);                                   \BUILD_BUG_ON_MSG(!__same_type(*(ptr), ((type *)0)-&gt;member) &amp;&amp;   \                 !__same_type(*(ptr), void),                    \                 &quot;pointer type mismatch in container_of()&quot;);    \</code></pre><p>首先内部声明一个__mptr来指向传入的ptr，接着做了一个类型检查，确保ptr和对应的成员变量类型一致，或者ptr兼容void类型（？），这两步只是预备工作。关键的在最后一步：</p><pre><code class="hljs plaintext">((type *)(__mptr - offsetof(type, member))); &#125;)</code></pre><p>offsetof宏会计算成员member在结构体里的偏移量，然后结构体成员的指针减去偏移量，就得到了结构体的指针。</p><p>总结下，<strong>container_of</strong>的实现依赖了下面三点：</p><ul><li>结构体在内存中的存放布局是连续的</li><li>结构体的起始地址和第一个成员变量的地址是一致的（编译器没有添加额外的信息在里面）</li><li>结构体的布局是从低地址到高地址增长的，偏移量为正</li></ul><p>Reference:</p><ol><li><a href="https://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html#Statement-Exprs">Statement</a></li><li><a href="https://gcc.gnu.org/onlinedocs/gcc/Typeof.html">Typeof</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;From linux 4.14&lt;/p&gt;</summary>
    
    
    
    
    <category term="kernel" scheme="http://example.com/tags/kernel/"/>
    
  </entry>
  
  <entry>
    <title>Copy a Git repo to a new one</title>
    <link href="http://example.com/2022/02/10/Copy-a-Git-repo-to-a-new-one/"/>
    <id>http://example.com/2022/02/10/Copy-a-Git-repo-to-a-new-one/</id>
    <published>2022-02-10T06:41:08.000Z</published>
    <updated>2022-04-06T12:32:13.902Z</updated>
    
    <content type="html"><![CDATA[<p>For some reason we need to copy all the things from one git repository to another, include the commit history. Below will show an instruction for how to do it.</p><span id="more"></span><ol><li>Create a new repo<br>This most by click the “create” button in some GUI or just do <strong>git init</strong> to create an empty repo</li></ol><blockquote><p>Note: “empty repo” means no need to create a initial commit, otherwise you need force override this commit later</p></blockquote><ol start="2"><li>Clone the new repo to local</li></ol><pre><code class="hljs plaintext">git clone https://github.com/new.git</code></pre><ol start="3"><li>Switch remote url to the old repo</li></ol><pre><code class="hljs plaintext">git remote set-url origin https://github.com/old.git</code></pre><ol start="4"><li>Fetch all from old repo</li></ol><pre><code class="hljs plaintext">git fetch</code></pre><p>The <strong>git fetch</strong> will only fetch the master branch, but if the old repo contains more branches, we also need to fetch them to local</p><pre><code class="hljs plaintext">git branch -r | grep -v &#x27;\-&gt;&#x27; | sed &quot;s,\x1B\[[0-9;]*[a-zA-Z],,g&quot; | while read remote; do git branch --track &quot;$&#123;remote#origin/&#125;&quot; &quot;$remote&quot;; done</code></pre><p>Now we got everything we want in our local repo</p><ol start="5"><li>Swtich back to new repo</li></ol><pre><code class="hljs plaintext">git remote set-url origin https://github.com/new.git</code></pre><ol start="6"><li>Push everything to new repo</li></ol><pre><code class="hljs plaintext">git push --all</code></pre><p>Also we need push all tags to remote repo</p><pre><code class="hljs plaintext">git push --tags</code></pre><p>Done</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;For some reason we need to copy all the things from one git repository to another, include the commit history. Below will show an instruction for how to do it.&lt;/p&gt;</summary>
    
    
    
    
    <category term="git" scheme="http://example.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>RTC，系统时间，NTP</title>
    <link href="http://example.com/2022/01/10/time/"/>
    <id>http://example.com/2022/01/10/time/</id>
    <published>2022-01-10T04:42:27.000Z</published>
    <updated>2024-03-31T02:48:54.231Z</updated>
    
    <content type="html"><![CDATA[<p>最近遇到一个 RTC 同步的问题，记录下并梳理下具体同步的流程：通常情况下，操作系统启动后，会首先从 RTC 读取时间，这时的系统时间完全来自于 RTC 芯片；如果后续开启了 NTP 服务，系统里的 NTP 服务会和网络上的 NTP 服务器进行时间校准（一般会持续几分钟），一旦系统时间和 NTP 服务器时间同步完成后，操作系统会把当前的系统时间写回 RTC 芯片，并且在随后的时间里，定期的（Linux 上每隔 11 分钟）将系统时间写回 RTC。</p><p>这里涉及到三条时间轴，RTC，系统时间和 NTP， 我们假设 NTP 的时间线是标准的，那他们三者之间同步的话，一般依赖于以下几个因素：</p><span id="more"></span><ul><li>每个时间数据能够提供的精度</li><li>每个时间线自身的误差</li><li>同步操作的时延</li></ul><p>能提供的精度，系统时间和 NTP 可以认为是足够的，单位一般为纳秒，精确度则基本在毫秒级。短板是 RTC 芯片，通常的 RTC 芯片提供的接口只能到秒，所以无论读取还是写入，都只能到秒，毫秒的数值完全被忽略了。</p><p>时间线自身的误差，RTC 依赖于芯片的晶振，通常情况下是满足需求的（具体误差可以参看芯片手册），系统时间的误差同样依赖于主芯片的晶振，NTP 服务器的话同样类似。</p><p>考虑同步操作的时延，NTP 和系统之间通常是通过网络，这部分虽然时延很大并且波动大，但 NTP 协议本身就已经考虑到并通过算法补偿掉了；RTC 和系统时间的同步通常通过 i2c 协议进行传输，一般可以忽略。</p><p>所以整体来看，影响整体系统精度的最大短板就在于 RTC 能提供的精度，即使系统的时间精度很高，但写入 RTC 时，只能写到秒一级的数据，产生的误差一下子就有+&#x2F;- 500ms 之多，同样道理，即使 RTC 本身的晶振精度很高，但系统刚起来去读时间的话，也只能读到秒，后面的毫秒数据完全没有，相当于又是- 1000ms 的误差。</p><p>所以如果想尽量让三者同步过程中保证获得一个高精度的数据，操作系统需要通过额外的一系列措施来实现，下面就通过代码梳理下系统是如何尽量补偿掉这个误差的。</p><p>涉及到的代码如下：</p><ul><li>openntpd-6.2p3</li></ul><ul><li>linux-4.19</li></ul><h2 id="NTP-gt-系统时间-gt-RTC"><a href="#NTP-gt-系统时间-gt-RTC" class="headerlink" title="NTP-&gt;系统时间-&gt;RTC"></a>NTP-&gt;系统时间-&gt;RTC</h2><p>首先当 ntpd 服务完成时间调整时，会把 synced 标志设置为 1：</p><pre><code class="hljs c"><span class="hljs-type">int</span><span class="hljs-title function_">ntpd_adjtime</span><span class="hljs-params">(<span class="hljs-type">double</span> d)</span>&#123;  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span>  <span class="hljs-title">tv</span>, <span class="hljs-title">olddelta</span>;</span>  <span class="hljs-type">int</span>   synced = <span class="hljs-number">0</span>;  <span class="hljs-type">static</span> <span class="hljs-type">int</span>  firstadj = <span class="hljs-number">1</span>;  d += getoffset();  <span class="hljs-keyword">if</span> (d &gt;= (<span class="hljs-type">double</span>)LOG_NEGLIGIBLE_ADJTIME / <span class="hljs-number">1000</span> ||      d &lt;= <span class="hljs-number">-1</span> * (<span class="hljs-type">double</span>)LOG_NEGLIGIBLE_ADJTIME / <span class="hljs-number">1000</span>)    log_info(<span class="hljs-string">&quot;adjusting local clock. The current time diff is now %fs&quot;</span>, d);  <span class="hljs-keyword">else</span>    log_debug(<span class="hljs-string">&quot;adjusting local clock. The current time diff is now %fs&quot;</span>, d);  d_to_tv(d, &amp;tv);  <span class="hljs-keyword">if</span> (adjtime(&amp;tv, &amp;olddelta) == <span class="hljs-number">-1</span>)    log_warn(<span class="hljs-string">&quot;adjtime failed&quot;</span>);  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!firstadj &amp;&amp; olddelta.tv_sec == <span class="hljs-number">0</span> &amp;&amp; olddelta.tv_usec == <span class="hljs-number">0</span>)    synced = <span class="hljs-number">1</span>;  firstadj = <span class="hljs-number">0</span>;  update_time_sync_status(synced);  <span class="hljs-keyword">return</span> (synced);&#125;</code></pre><p>update_time_sync_status()会通过系统调用 adjtimex()把时间设置到 kernel 里：</p><pre><code class="hljs c"><span class="hljs-type">void</span><span class="hljs-title function_">update_time_sync_status</span><span class="hljs-params">(<span class="hljs-type">int</span> synced)</span>&#123;        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timex</span> <span class="hljs-title">txc</span> =</span> &#123; <span class="hljs-number">0</span> &#125;;        txc.modes = MOD_STATUS;        <span class="hljs-keyword">if</span> (synced) &#123;                txc.modes |= MOD_MAXERROR;                txc.maxerror = <span class="hljs-number">0</span>;        &#125; <span class="hljs-keyword">else</span>                txc.status = STA_UNSYNC;        <span class="hljs-keyword">if</span> (adjtimex(&amp;txc) == <span class="hljs-number">-1</span>)                log_warn(<span class="hljs-string">&quot;ntp_adjtime (3) failed&quot;</span>);        <span class="hljs-keyword">return</span>;&#125;</code></pre><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">do_adjtimex</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> timex *txc)</span>&#123;   ... ...  ntp_notify_cmos_timer();  <span class="hljs-keyword">return</span> ret;&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">ntp_notify_cmos_timer</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;  <span class="hljs-keyword">if</span> (!ntp_synced()) <span class="hljs-comment">// 此处会check STA_UNSYNC标志</span>    <span class="hljs-keyword">return</span>;  <span class="hljs-keyword">if</span> (IS_ENABLED(CONFIG_GENERIC_CMOS_UPDATE) ||      IS_ENABLED(CONFIG_RTC_SYSTOHC))    queue_delayed_work(system_power_efficient_wq, &amp;sync_work, <span class="hljs-number">0</span>);&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * If we have an externally synchronized Linux clock, then update RTC clock</span><span class="hljs-comment"> * accordingly every ~11 minutes. Generally RTCs can only store second</span><span class="hljs-comment"> * precision, but many RTCs will adjust the phase of their second tick to</span><span class="hljs-comment"> * match the moment of update. This infrastructure arranges to call to the RTC</span><span class="hljs-comment"> * set at the correct moment to phase synchronize the RTC second tick over</span><span class="hljs-comment"> * with the kernel clock.</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">sync_hw_clock</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> work_struct *work)</span>&#123;  <span class="hljs-keyword">if</span> (!ntp_synced())    <span class="hljs-keyword">return</span>;  <span class="hljs-keyword">if</span> (sync_cmos_clock())    <span class="hljs-keyword">return</span>;  sync_rtc_clock();&#125;</code></pre><p>在 do_adjtimex()最后，会调用 ntp_notify_cmos_timer()，在 ntp_notify_cmos_timer()里 kernel 会启动一个 工作队列，并进入 sync_rtc_clock()</p><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">sync_rtc_clock</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> target_nsec;  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timespec64</span> <span class="hljs-title">adjust</span>, <span class="hljs-title">now</span>;</span>  <span class="hljs-type">int</span> rc;  <span class="hljs-keyword">if</span> (!IS_ENABLED(CONFIG_RTC_SYSTOHC))    <span class="hljs-keyword">return</span>;  getnstimeofday64(&amp;now);  adjust = now;  <span class="hljs-keyword">if</span> (persistent_clock_is_local)    adjust.tv_sec -= (sys_tz.tz_minuteswest * <span class="hljs-number">60</span>);  <span class="hljs-comment">/*</span><span class="hljs-comment">   * The current RTC in use will provide the target_nsec it wants to be</span><span class="hljs-comment">   * called at, and does rtc_tv_nsec_ok internally.</span><span class="hljs-comment">   */</span>  rc = rtc_set_ntp_time(adjust, &amp;target_nsec); <span class="hljs-comment">//这里第一次写入RTC，然后根据返回值rc来决定下一次同步的间隔</span>  <span class="hljs-keyword">if</span> (rc == -ENODEV)    <span class="hljs-keyword">return</span>;  sched_sync_hw_clock(now, target_nsec, rc);&#125;</code></pre><p>这里就涉及到之前提到的写入 RTC 产生的误差，kernel 会在这里做一个补偿，主要是通过多次写入来逼近。举例说明：假设系统获取到的当前时间为 m 秒 n 毫秒，第一次写入 RTC 时，只能先写入 m 秒，然后 kernel 计算出下一次写入的时间点是距离下一个整秒（m+1）的时间（1000 - n）毫秒，并通过定时器去触发下一次的写入操作。这样 1000-n 毫秒后，系统再一次去同步 RTC 时间，并写入 m+1 秒。这样 RTC 和系统的时间基本就到达一致了。</p><p>当然由于系统自身的误差（包括 CPU 调度的影响），有可能定时器触发的不是那么的精确，所以有可能需要再下一秒的同步，去设定时间（m+2）秒，通过这样不断的去逼近一个整秒的瞬间来对 RTC 进行同步。</p><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">sched_sync_hw_clock</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> timespec64 now,</span><span class="hljs-params">        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> target_nsec, <span class="hljs-type">bool</span> fail)</span>&#123;  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timespec64</span> <span class="hljs-title">next</span>;</span>  getnstimeofday64(&amp;next);  <span class="hljs-keyword">if</span> (!fail)    next.tv_sec = <span class="hljs-number">659</span>;  <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">/*</span><span class="hljs-comment">     * Try again as soon as possible. Delaying long periods</span><span class="hljs-comment">     * decreases the accuracy of the work queue timer. Due to this</span><span class="hljs-comment">     * the algorithm is very likely to require a short-sleep retry</span><span class="hljs-comment">     * after the above long sleep to synchronize ts_nsec.</span><span class="hljs-comment">     */</span>    next.tv_sec = <span class="hljs-number">0</span>;  &#125;  <span class="hljs-comment">/* Compute the needed delay that will get to tv_nsec == target_nsec */</span>  next.tv_nsec = target_nsec - next.tv_nsec;  <span class="hljs-keyword">if</span> (next.tv_nsec &lt;= <span class="hljs-number">0</span>)    next.tv_nsec += NSEC_PER_SEC;  <span class="hljs-keyword">if</span> (next.tv_nsec &gt;= NSEC_PER_SEC) &#123;    next.tv_sec++;    next.tv_nsec -= NSEC_PER_SEC;  &#125;  queue_delayed_work(system_power_efficient_wq, &amp;sync_work,         timespec64_to_jiffies(&amp;next));&#125;</code></pre><p>还有一点每次写入 RTC 之前，kernel 会比较当前时间是不是已经非常接近一个整秒，</p><pre><code class="hljs c"><span class="hljs-comment">/* The ntp code must call this with the correct value in tv_nsec, if</span><span class="hljs-comment"> * it does not we update target_nsec and return EPROTO to make the ntp</span><span class="hljs-comment"> * code try again later.</span><span class="hljs-comment"> */</span>ok = rtc_tv_nsec_ok(rtc-&gt;set_offset_nsec, &amp;to_set, &amp;now);<span class="hljs-keyword">if</span> (!ok) &#123;  err = -EPROTO;  <span class="hljs-keyword">goto</span> out_close;&#125;</code></pre><p>rtc_tv_nsec_ok()会 check 当前时间（now）的 tv_nsec 是不是等于 rtc-&gt;set_offset_nsec+&#x2F;-FUZZ</p><pre><code class="hljs c"><span class="hljs-comment">/* Allowed error in tv_nsec, arbitarily set to 5 jiffies in ns. */</span><span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> TIME_SET_NSEC_FUZZ = TICK_NSEC * <span class="hljs-number">5</span>;</code></pre><p>如果满足误差范围，并且写入 RTC 成功，这一次的同步就完成了。kernel 会把下一次同步设定在 11 分钟后。</p><p>另一个需要注意的是，上面说的整秒其实不是默认行为，4.19 kernel 里的 rtc-&gt;set_offset_nsec，对应的就是想在哪个时间点同步 RTC，默认 rtc 驱动里设置为半秒，如果想做到整秒的同步，需要在驱动里把它改为 0。</p><h2 id="RTC-gt-系统时间"><a href="#RTC-gt-系统时间" class="headerlink" title="RTC-&gt;系统时间"></a>RTC-&gt;系统时间</h2><p>反过来，当系统从断电状态启动时，kernel 会从 RTC 里读取时间，并作为系统时间。如果系统运行中没有网络或者没有 enable NTP 服务，那系统时间的精度完全依赖于从 RTC 里读取的时间。但不幸的是，读取 RTC 一般也只能读到秒，所以默认情况下，系统获取的时间都是不精确的。</p><pre><code class="hljs c"><span class="hljs-comment">/* IMPORTANT: the RTC only stores whole seconds. It is arbitrary</span><span class="hljs-comment"> * whether it stores the most close value or the value with partial</span><span class="hljs-comment"> * seconds truncated. However, it is important that we use it to store</span><span class="hljs-comment"> * the truncated value. This is because otherwise it is necessary,</span><span class="hljs-comment"> * in an rtc sync function, to read both xtime.tv_sec and</span><span class="hljs-comment"> * xtime.tv_nsec. On some processors (i.e. ARM), an atomic read</span><span class="hljs-comment"> * of &gt;32bits is not possible. So storing the most close value would</span><span class="hljs-comment"> * slow down the sync API. So here we have the truncated value and</span><span class="hljs-comment"> * the best guess is to add 0.5s.</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">rtc_hctosys</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-type">int</span> err = -ENODEV;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rtc_time</span> <span class="hljs-title">tm</span>;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timespec64</span> <span class="hljs-title">tv64</span> =</span> &#123;.tv_nsec = NSEC_PER_SEC &gt;&gt; <span class="hljs-number">1</span>,&#125;;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rtc_device</span> *<span class="hljs-title">rtc</span> =</span> rtc_class_open(CONFIG_RTC_HCTOSYS_DEVICE);<span class="hljs-keyword">if</span> (rtc == <span class="hljs-literal">NULL</span>) &#123;pr_info(<span class="hljs-string">&quot;unable to open rtc device (%s)\n&quot;</span>,CONFIG_RTC_HCTOSYS_DEVICE);<span class="hljs-keyword">goto</span> err_open;&#125;err = rtc_read_time(rtc, &amp;tm);<span class="hljs-keyword">if</span> (err) &#123;dev_err(rtc-&gt;dev.parent,<span class="hljs-string">&quot;hctosys: unable to read the hardware clock\n&quot;</span>);<span class="hljs-keyword">goto</span> err_read;&#125;tv64.tv_sec = rtc_tm_to_time64(&amp;tm);<span class="hljs-meta">#<span class="hljs-keyword">if</span> BITS_PER_LONG == 32</span><span class="hljs-keyword">if</span> (tv64.tv_sec &gt; INT_MAX) &#123;err = -ERANGE;<span class="hljs-keyword">goto</span> err_read;&#125;<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>err = do_settimeofday64(&amp;tv64);dev_info(rtc-&gt;dev.parent,<span class="hljs-string">&quot;setting system clock to &quot;</span><span class="hljs-string">&quot;%d-%02d-%02d %02d:%02d:%02d UTC (%lld)\n&quot;</span>,tm.tm_year + <span class="hljs-number">1900</span>, tm.tm_mon + <span class="hljs-number">1</span>, tm.tm_mday,tm.tm_hour, tm.tm_min, tm.tm_sec,(<span class="hljs-type">long</span> <span class="hljs-type">long</span>) tv64.tv_sec);err_read:rtc_class_close(rtc);err_open:rtc_hctosys_ret = err;<span class="hljs-keyword">return</span> err;&#125;</code></pre><p>如上面代码里的那样，kernel 会默认填充 nsec 为半秒，也就是 500ms，所以系统时间在同步完后，已经有了+&#x2F;- 500ms 的偏差。</p><p>如果未了同步时获得更高精度的时间，就需要额外的步骤来实现，通常有下面两种方法：</p><ol><li>类似 kernel 同步 RTC 时，采用不断逼近写入时间的方法，在我们从 RTC 读取时间时，我们也可以通过以固定的一个间隔来读取 RTC 时间，例如，假设我们间隔设为 d ms， 第一次读取时我们得到的时间是 T 秒，然后等待 d ms，再次读取 RTC，如果还是 T 秒，重复上述循环；如果读到 T+1 秒，那就退出循环，并立即同步系统时间为 T+1 秒，这样同步下来的精度可以达到 d ms （当然理论上需要加上系统定时器的精度）。</li><li>通过利用 RTC 芯片上的中断管脚，有些 RTC 芯片的中断管脚上可以产生一个以 1 秒作为周期中断信号，这样 kernel 里可以在第一个中断到来时，读取下 RTC 时间，记为 T 秒，然后等到下一个中断到来时，立即同步系统时间为 T+1 秒（采用两个中断主要是规避读取 RTC 带来的一些耗时），这样同步的结果可以达到比较高的精度。</li></ol><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>下面是一次完整的系统从 NTP 同步，到系统同步到 RTC 的过程</p><pre><code class="hljs plaintext">May 27 09:42:14  systemd[1]: Started Network time.May 27 09:42:14  kernel: do_adjtimex ...May 27 09:42:14  kernel: do_adjtimex ...May 27 09:42:14  ntpd[868]: ntp engine readyMay 27 09:42:14  kernel: do_adjtimex ...May 27 09:42:15  kernel: do_adjtimex ...May 27 09:42:15  ntpd[867]: set local clock to Thu May 27 09:42:15 UTC 2021 (offset 0.027322s)May 27 09:42:22  kernel: do_adjtimex ...May 27 09:42:22  kernel: do_adjtimex ...May 27 09:42:31  kernel: do_adjtimex ...May 27 09:42:31  kernel: do_adjtimex ...May 27 09:42:37  kernel: do_adjtimex ...May 27 09:42:37  ntpd[868]: peer 10.0.2.201 now validMay 27 09:42:37  kernel: do_adjtimex ...May 27 09:42:45  kernel: do_adjtimex ...... ...May 27 09:45:09  kernel: do_adjtimex ...May 27 09:45:39  kernel: do_adjtimex ...May 27 09:45:39  ntpd[868]: clock is now syncedMay 27 09:45:39  kernel: do_adjtimex ...May 27 09:45:39  kernel: do_adjtimex ...May 27 09:45:39  kernel: do_adjtimex ...May 27 09:45:39  kernel: do_adjtimex ...May 27 09:45:39  kernel: do_adjtimex ...May 27 09:45:39  kernel: pass ntp_syncedMay 27 09:45:39  kernel: sync_hw_clock ...May 27 09:45:39  kernel: write rtc timeMay 27 09:45:39  kernel: tv_nsec: 887729612 (50000000)May 27 09:45:39  kernel: now: 887729612, target: 0May 27 09:45:39  kernel: sched_sync_hw_clock 0:111891499 target 0May 27 09:45:40  kernel: sync_hw_clock ...May 27 09:45:40  kernel: write rtc timeMay 27 09:45:40  kernel: tv_nsec: 13155982 (50000000)May 27 09:45:40  kernel: now: 13155982, target: 0May 27 09:45:40  kernel: sched_sync_hw_clock 659:983555780 target 0May 27 09:46:12  kernel: do_adjtimex ...May 27 09:46:12  kernel: pass ntp_syncedMay 27 09:46:13  kernel: do_adjtimex ...May 27 09:46:13  kernel: pass ntp_synced... ...May 27 09:56:28  kernel: do_adjtimex ...May 27 09:56:28  kernel: pass ntp_syncedMay 27 09:56:44  kernel: sync_hw_clock ...May 27 09:56:44  kernel: write rtc timeMay 27 09:56:44  kernel: tv_nsec: 403066775 (50000000)May 27 09:56:44  kernel: now: 403066775, target: 0May 27 09:56:44  kernel: sched_sync_hw_clock 0:596448364 target 0May 27 09:56:45  kernel: sync_hw_clock ...May 27 09:56:45  kernel: write rtc timeMay 27 09:56:45  kernel: tv_nsec: 12466498 (50000000)May 27 09:56:45  kernel: now: 12466498, target: 0May 27 09:56:45  kernel: sched_sync_hw_clock 659:983911530 target 0</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近遇到一个 RTC 同步的问题，记录下并梳理下具体同步的流程：通常情况下，操作系统启动后，会首先从 RTC 读取时间，这时的系统时间完全来自于 RTC 芯片；如果后续开启了 NTP 服务，系统里的 NTP 服务会和网络上的 NTP 服务器进行时间校准（一般会持续几分钟），一旦系统时间和 NTP 服务器时间同步完成后，操作系统会把当前的系统时间写回 RTC 芯片，并且在随后的时间里，定期的（Linux 上每隔 11 分钟）将系统时间写回 RTC。&lt;/p&gt;
&lt;p&gt;这里涉及到三条时间轴，RTC，系统时间和 NTP， 我们假设 NTP 的时间线是标准的，那他们三者之间同步的话，一般依赖于以下几个因素：&lt;/p&gt;</summary>
    
    
    
    
    <category term="kernel" scheme="http://example.com/tags/kernel/"/>
    
  </entry>
  
  <entry>
    <title>Cargo build timing</title>
    <link href="http://example.com/2021/08/17/cargo-build-timing/"/>
    <id>http://example.com/2021/08/17/cargo-build-timing/</id>
    <published>2021-08-17T05:59:33.000Z</published>
    <updated>2022-04-06T12:32:13.902Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>Switch to nightly version</p><pre><code class="hljs plaintext">rustup default nightly-x86_64-unknown-linux-gnu</code></pre></li><li><p>Run Cargo build with “-Z timings”</p><pre><code class="hljs plaintext">cargo build -Z timings</code></pre></li><li><p>Check the output report<br>Example: <a href="/html/cargo-timing.html">cargo-timing.html</a></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Switch to nightly version&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs plaintext&quot;&gt;rustup default nightly-x86_64-unknown-linux-gnu&lt;/code&gt;&lt;/pre&gt;
&lt;/l</summary>
      
    
    
    
    
    <category term="rust" scheme="http://example.com/tags/rust/"/>
    
  </entry>
  
  <entry>
    <title>lstopo</title>
    <link href="http://example.com/2021/07/20/lstopo/"/>
    <id>http://example.com/2021/07/20/lstopo/</id>
    <published>2021-07-20T05:46:32.000Z</published>
    <updated>2022-04-06T12:32:13.902Z</updated>
    
    <content type="html"><![CDATA[<p>A tool to show HW topo</p><span id="more"></span><pre><code class="hljs plaintext">apt-get install hwloc</code></pre><p><img src="/lstopo.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;A tool to show HW topo&lt;/p&gt;</summary>
    
    
    
    
    <category term="Tool" scheme="http://example.com/tags/Tool/"/>
    
  </entry>
  
  <entry>
    <title>QEMU</title>
    <link href="http://example.com/2021/04/10/qemu/"/>
    <id>http://example.com/2021/04/10/qemu/</id>
    <published>2021-04-10T04:42:27.000Z</published>
    <updated>2024-03-31T02:13:14.882Z</updated>
    
    <content type="html"><![CDATA[<p><em>QEMU is a generic and open source machine emulator and virtualizer.</em></p><h2 id="Boot-the-Linux"><a href="#Boot-the-Linux" class="headerlink" title="Boot the Linux"></a>Boot the Linux</h2><span id="more"></span><ol><li><p>Download the kernel:</p><p><code>git clone https://github.com/torvalds/linux.git linux</code></p></li><li><p>Install the tool-chain:</p><p><code>sudo apt-get install gcc-arm-linux-gnueabi</code></p></li><li><p>Compile the kernel:</p><p><code>make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- vexpress_defconfig</code></p><p><code>make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- menuconfig</code></p><p><code>make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- -j8</code></p><blockquote><p>Tips:</p><p>** <code>qemu-system-arm -machine help</code> can list the support machines</p></blockquote><p>vexpress means: <em>express-a9          ARM Versatile Express for Cortex-A9</em>  and <a href="http://infocenter.arm.com/help/topic/com.arm.doc.dui0448i/DUI0448I_v2p_ca9_trm.pdf">spec</a> here. We will run Linux on this ARM development board.</p></li><li><p>Install qemu:</p><p><code>sudo apt-get install qemu qemu-system-arm</code></p></li><li><p>Prepare the rootfs</p><p>There are many ways to choose rootfs, e.g. busybox, buildroot and some linux distribution. Here  we use buildroot as an example.</p><p>a. Download the source code from: <a href="https://buildroot.org/downloads/buildroot-2019.02.2.tar.bz2">https://buildroot.org/downloads/buildroot-2019.02.2.tar.bz2</a></p><p>b. Extra the file and run “make menuconfig”</p><pre><code class="hljs plaintext">#Set to the proper processor if you use different CPUTarget options ---&gt;    Target Architecture (ARM (little endian))    Target Binary Format (ELF)    Target Architecture Variant (cortex-A9)    Target ABI (EABI)    Floating point strategy (Soft float)    ARM instruction set (ARM)#I prefer this toolchain rather than buildroot&#x27;sToolchain ---&gt;    Toolchain type (External toolchain)    Toolchain (Sourcery CodeBench ARM 2014.05)    Toolchain origin (Toolchain to be downloaded and installed)#This is the minimal setting one could use.System configuration ---&gt;    Init system (BusyBox)    /dev management (Dynamic using devtmpfs only)    [*] Enable root login with password    (root) Root password        /bin/sh (busybox&#x27; default shell)#CPIO is more compatible and has readonly property when executing QEMUFilesystem images ---&gt;    [*] cpio the root filesystem (for use as an initial RAM filesystem)</code></pre><p>The benefit to use buildroot is easy to deploy lots of tools and packages you want. E.g. dhcpcd, web server, python etc.</p><p>c. Run “make” to build the image</p><p>d. The final result will placed on buildroot&#x2F;output&#x2F;images&#x2F;rootfs.cpio</p></li><li><p>Start the QEMU</p><pre><code class="hljs plaintext">qemu-system-arm \-M vexpress-a9 \-m 1024 \-smp 4 \-dtb linux/arch/arm/boot/dts/vexpress-v2p-ca9.dtb \-kernel linux/arch/arm/boot/zImage \-nographic \-append &quot;console=ttyAMA0&quot; \-initrd ./buildroot-2019.02.2/output/images/rootfs.cpio</code></pre><p>Enjoy the Linux!</p><blockquote><p>Tips:</p><p>** To quit the QEMU, Ctrl + a and x</p></blockquote></li></ol><h2 id="Make-the-network-work"><a href="#Make-the-network-work" class="headerlink" title="Make the network work"></a>Make the network work</h2><p>The network will auto setup when system start. Install one dhcp client in your rootfs then you will get the address from default dhcp server in QEMU. To allow SSH from host, also need to configure a port forward in QEMU, the whole command is:</p><pre><code class="hljs plaintext">-net user,hostfwd=tcp::10022-:22 -net nic</code></pre><p>See this <a href="https://wiki.qemu.org/Documentation/Networking">link</a> for detail.</p><h2 id="GDB-with-QEMU"><a href="#GDB-with-QEMU" class="headerlink" title="GDB with QEMU"></a>GDB with QEMU</h2><p>There is a internal gdb-server in QEMU, enable it by pass below option:</p><pre><code class="hljs plaintext">-sShorthand for -gdb tcp::1234, i.e. open a gdbserver on TCP port 1234 (see gdb_usage).</code></pre><p>and also with:</p><pre><code class="hljs plaintext">-SDo not start CPU at startup (you must type ’c’ in the monitor).</code></pre><p>Then run the gdb as a normal gdb client in your terminal:</p><pre><code class="hljs plaintext">gdb-multiarch --tui(gdb) file linux/vmlinuxReading symbols from linux/vmlinux...done.(gdb) target remote:1234Remote debugging using :12340x60000000 in ?? ()(gdb)</code></pre><p>Also run gdb in vscode, config the launch.json as below:</p><pre><code class="hljs plaintext">...                     &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/vmlinux&quot;,                     &quot;miDebuggerPath&quot;: &quot;/usr/bin/gdb-multiarch&quot;,                     &quot;miDebuggerServerAddress&quot;: &quot;localhost:1234&quot;,...</code></pre><h2 id="Share-folder"><a href="#Share-folder" class="headerlink" title="Share folder"></a>Share folder</h2><p>To make it possible to share file between QEMU guest and host, we could mount a host folder to the QEMU guest by below command:</p><pre><code class="hljs plaintext">--fsdev local,id=kmod,path=$PWD/mnt,security_model=none -device virtio-9p-device,fsdev=kmod,mount_tag=share</code></pre><p>So mnt folder in current host PWD will map to a share mount point in QEMU guest, then we could mount it to &#x2F;mnt in QEMU guest system by editing the &#x2F;etc&#x2F;fstab like:</p><pre><code class="hljs plaintext">share           /mnt            9p      trans=virtio  00</code></pre><h2 id="Kernel-debug-fs"><a href="#Kernel-debug-fs" class="headerlink" title="Kernel debug fs"></a>Kernel debug fs</h2><p>Add below to &#x2F;etc&#x2F;fstab</p><pre><code class="hljs plaintext">debugfs    /sys/kernel/debug      debugfs  defaults  0 0</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;em&gt;QEMU is a generic and open source machine emulator and virtualizer.&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;Boot-the-Linux&quot;&gt;&lt;a href=&quot;#Boot-the-Linux&quot; class=&quot;headerlink&quot; title=&quot;Boot the Linux&quot;&gt;&lt;/a&gt;Boot the Linux&lt;/h2&gt;</summary>
    
    
    
    
    <category term="kernel" scheme="http://example.com/tags/kernel/"/>
    
  </entry>
  
  <entry>
    <title>Debug one connection issue of curl with git bisect</title>
    <link href="http://example.com/2021/03/03/curl/"/>
    <id>http://example.com/2021/03/03/curl/</id>
    <published>2021-03-03T07:36:17.000Z</published>
    <updated>2022-04-06T12:32:13.902Z</updated>
    
    <content type="html"><![CDATA[<p>When use below curl command to connect to an IPv6 device, it works on my Debian 9:</p><pre><code class="hljs shell">curl -D - -S -T fimage ftp://root:pass@[fe80::baa4:4fff:fe0a:e3cb%eth1]/flash</code></pre><p>but after upgrade the system to Debian 10, it failed with below error:<br><strong>curl: (3) URL using bad&#x2F;illegal format or missing URL</strong><br>it looks the curl broken after the upgrade.</p><span id="more"></span><p>Debian 10</p><pre><code class="hljs plaintext">curl 7.64.0 (x86_64-pc-linux-gnu) libcurl/7.64.0 OpenSSL/1.1.1d zlib/1.2.11 libidn2/2.0.5 libpsl/0.20.2 (+libidn2/2.0.5) libssh2/1.8.0 nghttp2/1.36.0 librtmp/2.3Release-Date: 2019-02-06Protocols: dict file ftp ftps gopher http https imap imaps ldap ldaps pop3 pop3s rtmp rtsp scp sftp smb smbs smtp smtps telnet tftpFeatures: AsynchDNS IDN IPv6 Largefile GSS-API Kerberos SPNEGO NTLM NTLM_WB SSL libz TLS-SRP HTTP2 UnixSockets HTTPS-proxy PSL</code></pre><p>Debian 9</p><pre><code class="hljs plaintext">curl 7.52.1 (x86_64-pc-linux-gnu) libcurl/7.52.1 OpenSSL/1.0.2u zlib/1.2.11 libidn2/2.0.5 libpsl/0.17.0 (+libidn2/0.16) libssh2/1.7.0 nghttp2/1.18.1 librtmp/2.3Protocols: dict file ftp ftps gopher http https imap imaps ldap ldaps pop3 pop3s rtmp rtsp scp sftp smb smbs smtp smtps telnet tftpFeatures: AsynchDNS IDN IPv6 Largefile GSS-API Kerberos SPNEGO NTLM NTLM_WB SSL libz TLS-SRP HTTP2 UnixSockets HTTPS-proxy PSL</code></pre><p>I would like to know from which version of curl is broke. Then <strong>git bisect</strong> comes to help.</p><ol><li>Download the source code of Curl</li></ol><pre><code class="hljs plaintext">git clone https://github.com/curl/curl.git</code></pre><ol start="2"><li>Mark the start(bad) and stop(good) rev</li></ol><pre><code class="hljs plaintext">git co curl-7_64_0 # This is bad revgit bisect start HEAD curl-7_52_1</code></pre><ol start="3"><li>Make a simple scrip to verify if the current version of curl is good or not</li></ol><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/sh</span>&#123; make clean &amp;&amp; autoreconf -i &amp;&amp; ./configure --enable-ipv6 &amp;&amp; make; &#125; &gt; /dev/null./src/curl ftp://root:pass@[fe80::baa4:4fff:fe0a:e3cb%eth1]/etc/ntpd.conf &gt; /dev/null 2&gt;&amp;1exit $?</code></pre><p><strong>NOTE: Be careful with the return value of the script:</strong></p><blockquote><p>… exit with code 0 if the current source code is good&#x2F;old, and exit with a code between 1 and 127 (inclusive), except 125, if the current source code is bad&#x2F;new.</p></blockquote><ol start="4"><li>Run the bisect</li></ol><pre><code class="hljs plaintext">$ git bisect run ./check_curl.shrunning ./check_curl.shconfigure: WARNING: OpenSSL headers and library versions do not match./usr/bin/ar: `u&#x27; modifier ignored since `D&#x27; is the default (see `U&#x27;)Bisecting: 642 revisions left to test after this (roughly 9 steps)[685dc3c082504898e2925d635ab7241c9b8a3b20] lib/curl_setup.h: remove unicode characterrunning ./check_curl.shIn function ‘ossl_keylog_callback.part.2’,    inlined from ‘ossl_keylog_callback’ at vtls/openssl.c:238:13:vtls/openssl.c:256:5: warning: ‘strncpy’ specified bound depends on the length of the source argument [-Wstringop-overflow=]     strncpy(buf, line, linelen);     ^~~~~~~~~~~~~~~~~~~~~~~~~~~vtls/openssl.c: In function ‘ossl_keylog_callback’:vtls/openssl.c:247:22: note: length computed here     size_t linelen = strlen(line);                      ^~~~~~~~~~~~Bisecting: 321 revisions left to test after this (roughly 8 steps)[238494fc819ad4b63d3e56ca657b7af75efcfead] KNOWN_BUGS: Fix various typosrunning ./check_curl.shBisecting: 160 revisions left to test after this (roughly 7 steps)[d7c4213bd0cfd16054fa75a887d3e1a9a796cb53] multiplex: enable by defaultrunning ./check_curl.shIn function ‘ossl_keylog_callback.part.2’,    inlined from ‘ossl_keylog_callback’ at vtls/openssl.c:238:13:vtls/openssl.c:256:5: warning: ‘strncpy’ specified bound depends on the length of the source argument [-Wstringop-overflow=]     strncpy(buf, line, linelen);     ^~~~~~~~~~~~~~~~~~~~~~~~~~~vtls/openssl.c: In function ‘ossl_keylog_callback’:vtls/openssl.c:247:22: note: length computed here     size_t linelen = strlen(line);                      ^~~~~~~~~~~~Bisecting: 80 revisions left to test after this (roughly 6 steps)[46e164069d1a5230e4e64cbd2ff46c46cce056bb] url: use the URL API internally as wellrunning ./check_curl.shBisecting: 39 revisions left to test after this (roughly 5 steps)[ddb06ffc0f680322ce746c6e8d524dee4de84955] urlglob: improve error messagerunning ./check_curl.shBisecting: 19 revisions left to test after this (roughly 4 steps)[23524bf85b887adbc513bc015c9530355967bc04] examples: Fix memory leaks from realloc errorsrunning ./check_curl.shBisecting: 9 revisions left to test after this (roughly 3 steps)[5c73093edb3bd527db9c8abdee53d0f18e6a4cc1] urlapi: document the error codes, remove two unused onesrunning ./check_curl.shBisecting: 4 revisions left to test after this (roughly 2 steps)[2097cd515289581df5dfb6eeb5942d083a871fa4] urlapi: fix support for address scope in IPv6 numerical addressesrunning ./check_curl.shBisecting: 2 revisions left to test after this (roughly 1 step)[6f0afb842c733034bf36b553059270321b38c856] configure: force-use -lpthreads on HPUXrunning ./check_curl.shBisecting: 0 revisions left to test after this (roughly 1 step)[f078361c0e2539689df9962f35ab22f8ea25afe9] URL and mailmap updates, remove an obsolete directory [ci skip]running ./check_curl.sh46e164069d1a5230e4e64cbd2ff46c46cce056bb is the first bad commitcommit 46e164069d1a5230e4e64cbd2ff46c46cce056bbAuthor: Daniel Stenberg &lt;daniel@haxx.se&gt;Date:   Fri Sep 14 23:33:28 2018 +0200    url: use the URL API internally as well    ... to make it a truly unified URL parser.    Closes #3017:040000 040000 fada85f23dcfaea3100d7fcce418f65d1ae983f3 ed327b156ba705d3ed0f506ed11b625d6445f49d Mlib:040000 040000 810ff4be3b0caad4c6bc3a1aa53a067c68310874 2961ccc75c6a17f647f5b36b63f8a83bc6e60653 Mtestsbisect run success</code></pre><p>Just in few minutes, I could find the wrong commit which broke the function. :)</p><ol start="5"><li>Replay what did ‘git bisect’ do with <strong>git bisect log</strong></li></ol><pre><code class="hljs plaintext">$ git bisect log# bad: [f3294d9d86e6a7915a967efff2842089b8b0d071] RELEASE-NOTES: 7.64.0# good: [44b9b4d4f56d6f6de92c89636994c03984e9cd01] RELEASE-NOTES: curl 7.52.1git bisect start &#x27;HEAD&#x27; &#x27;curl-7_52_1&#x27;# good: [d3ab7c5a21ebfa0e3ceb3a395f23aceb5ddc58b6] openssl: fix too broad use of HAVE_OPAQUE_EVP_PKEYgit bisect good d3ab7c5a21ebfa0e3ceb3a395f23aceb5ddc58b6# good: [685dc3c082504898e2925d635ab7241c9b8a3b20] lib/curl_setup.h: remove unicode charactergit bisect good 685dc3c082504898e2925d635ab7241c9b8a3b20# bad: [238494fc819ad4b63d3e56ca657b7af75efcfead] KNOWN_BUGS: Fix various typosgit bisect bad 238494fc819ad4b63d3e56ca657b7af75efcfead# good: [d7c4213bd0cfd16054fa75a887d3e1a9a796cb53] multiplex: enable by defaultgit bisect good d7c4213bd0cfd16054fa75a887d3e1a9a796cb53# bad: [46e164069d1a5230e4e64cbd2ff46c46cce056bb] url: use the URL API internally as wellgit bisect bad 46e164069d1a5230e4e64cbd2ff46c46cce056bb# good: [ddb06ffc0f680322ce746c6e8d524dee4de84955] urlglob: improve error messagegit bisect good ddb06ffc0f680322ce746c6e8d524dee4de84955# good: [23524bf85b887adbc513bc015c9530355967bc04] examples: Fix memory leaks from realloc errorsgit bisect good 23524bf85b887adbc513bc015c9530355967bc04# good: [5c73093edb3bd527db9c8abdee53d0f18e6a4cc1] urlapi: document the error codes, remove two unused onesgit bisect good 5c73093edb3bd527db9c8abdee53d0f18e6a4cc1# good: [2097cd515289581df5dfb6eeb5942d083a871fa4] urlapi: fix support for address scope in IPv6 numerical addressesgit bisect good 2097cd515289581df5dfb6eeb5942d083a871fa4# good: [6f0afb842c733034bf36b553059270321b38c856] configure: force-use -lpthreads on HPUXgit bisect good 6f0afb842c733034bf36b553059270321b38c856# good: [f078361c0e2539689df9962f35ab22f8ea25afe9] URL and mailmap updates, remove an obsolete directory [ci skip]git bisect good f078361c0e2539689df9962f35ab22f8ea25afe9# first bad commit: [46e164069d1a5230e4e64cbd2ff46c46cce056bb] url: use the URL API internally as well</code></pre><p>At last, remember to finish the bisect by <strong>git bisect reset</strong>.</p><ol start="6"><li>More</li></ol><p>Actually when I debug this issue, I also build the curl with the latest version on my Debian 10, it also work. So I’m interestig for which commit fix this issue since curl-7_64_0. The <strong>git bisect</strong> also can help on it.<br>The latest version is “curl-7_75_0”, I will mark this as “fixed”, and “unfixed” on “curl-7_64_0” as below</p><pre><code class="hljs plaintext">$ git co curl-7_75_0Previous HEAD position was a0c461434 gtls: survive not being able to get name/issuerHEAD is now at 2f33be817 RELEASE-NOTES: syncedchenhuiz@lnxchenhuiz2:~/work/curl$ git bisect start --term-new=fixed --term-old=unfixedchenhuiz@lnxchenhuiz2:~/work/curl$ git bisect fixed HEADchenhuiz@lnxchenhuiz2:~/work/curl$ git bisect unfixed curl-7_64_0Bisecting: 1412 revisions left to test after this (roughly 11 steps)[1722eb83b4adf879426908bc6006f869ca224564] curl_getenv.3: Fix the memory handling description</code></pre><p>Then for the script, I need to modify the return value to match the rule for <strong>git bisect</strong></p><pre><code class="hljs plaintext">#!/bin/sh&#123; make clean &amp;&amp; autoreconf -i &amp;&amp; ./configure --enable-ipv6 &amp;&amp; make; &#125; &gt; /dev/nullif ./src/curl ftp://root:pass@[fe80::baa4:4fff:fe0a:e3cb%eth1]/etc/ntpd.conf &gt; /dev/null 2&gt;&amp;1; thenexit 1;elseexit 0fi</code></pre><p>The progress is also smooth:</p><pre><code class="hljs plaintext">$ git bisect run ./check_curl.shrunning ./check_curl.shBisecting: 705 revisions left to test after this (roughly 10 steps)[887ebc384c5687a8e154b3b6feb74cdaa8df4adc] ngtcp2: don&#x27;t reinitialize SSL on Retryrunning ./check_curl.shBisecting: 352 revisions left to test after this (roughly 9 steps)[ae3f838b9a8b185d98b2a5442a3d220ac9a3a11d] RELEASE-NOTES: syncedrunning ./check_curl.shBisecting: 176 revisions left to test after this (roughly 8 steps)[35b8bea20f90873e321e1e77d8a9936245c11ac9] tests: update fixed IP for hostip/clientip splitrunning ./check_curl.shBisecting: 87 revisions left to test after this (roughly 7 steps)[44ea2bef38f3f66f6c4f2ef5f965c7008e628c26] appveyor: add support for other build systemsrunning ./check_curl.shBisecting: 43 revisions left to test after this (roughly 6 steps)[8fba2d6a6b15ca287740a36715d679825c38df83] url: convert the zone id from a IPv6 URL to correct scope idrunning ./check_curl.shBisecting: 21 revisions left to test after this (roughly 5 steps)[3cfcdf08d85488d162ce10a6ce5433dbe510264d] hostip: CURL_DISABLE_SHUFFLE_DNSrunning ./check_curl.shBisecting: 10 revisions left to test after this (roughly 4 steps)[320cec284d142e67cdf3f6c76f3851449991d87f] ssh: move variable declaration to where it&#x27;s usedrunning ./check_curl.shBisecting: 5 revisions left to test after this (roughly 3 steps)[0da8441298569dfd714e7b21f74aab373b95d2f7] mbedtls: enable use of EC keysrunning ./check_curl.shBisecting: 2 revisions left to test after this (roughly 2 steps)[528b284e4b145ff38c5ab87b4d6daa5d796fd938] udpateconninfo: mark variable unusedrunning ./check_curl.shBisecting: 0 revisions left to test after this (roughly 1 step)[9406d93e77e7923e2788e43df50cf3a577f1c42b] configure: detect getsockname and getpeername on windows toorunning ./check_curl.sh8fba2d6a6b15ca287740a36715d679825c38df83 is the first fixed commitcommit 8fba2d6a6b15ca287740a36715d679825c38df83Author: Daniel Stenberg &lt;daniel@haxx.se&gt;Date:   Tue May 21 09:43:10 2019 +0200    url: convert the zone id from a IPv6 URL to correct scope id    Reported-by: GitYuanQu on github    Fixes #3902    Closes #3914:040000 040000 2013af3dc3dce59d10c55213151f0b63c3bad53f cca388c0c0e568c6f9f0d05c0c8c2f4197ad4f1b Mlibbisect run success</code></pre><p>That’s it!</p><p>Reference: <a href="https://git-scm.com/docs/git-bisect">git bisect</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;When use below curl command to connect to an IPv6 device, it works on my Debian 9:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs shell&quot;&gt;curl -D - -S -T fimage ftp://root:pass@[fe80::baa4:4fff:fe0a:e3cb%eth1]/flash&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;but after upgrade the system to Debian 10, it failed with below error:&lt;br&gt;&lt;strong&gt;curl: (3) URL using bad&amp;#x2F;illegal format or missing URL&lt;/strong&gt;&lt;br&gt;it looks the curl broken after the upgrade.&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
